{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/ReduxFlow.png","path":"img/ReduxFlow.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/Summary.md","hash":"bc0af2d9bac0071bbdf8f2e709022ecde15352c8","modified":1490851026000},{"_id":"source/_posts/background.md","hash":"8cc60e63b469954dbd4b16c50328a081173099c7","modified":1490851026000},{"_id":"source/_posts/redux.md","hash":"4067e11a530c67d0d65a5695dbf52f26e4ee5e50","modified":1490851026000},{"_id":"source/archive/index.md","hash":"69040c7f2032b8e4a205b79210ada85f8dd7c5c1","modified":1490851026000},{"_id":"source/img/ReduxFlow.png","hash":"a3c62d2d79510ce6216de272d10db1f2b959da32","modified":1490851026000}],"Category":[],"Data":[],"Page":[{"title":"archive","date":"2017-03-26T09:42:00.000Z","_content":"","source":"archive/index.md","raw":"---\ntitle: archive\ndate: 2017-03-26 17:42:00\n---\n","updated":"2017-03-30T05:17:06.000Z","path":"archive/index.html","comments":1,"layout":"page","_id":"cj0w763pb000b42cdow8mwg9m","content":"","excerpt":"","more":""}],"Post":[{"title":"Summary","date":"2017-03-21T11:11:05.000Z","_content":"## node线分享书籍\n1. **《了不起的nodejs》**：分10个课时\n2. **《深入浅出nodejs》**：分10个课时\n\n## 课程表\n\n### 《了不起的nodejs》\n\n\n| 课时章节       |  日期         |  讲师  |\n| ------------- |:-------------:| -----:|\n|  1. 基础知识 |   | 陈宇 |\n|  2. CLI   |   | 倪敏 |\n|  3. TCP HTTP  |   | 徐佳 |\n|  4. Connect & Express   |   | 林宇宏 |\n|  5. 数据库   |   | 林宇宏 |\n|  6. Redis   |   | 倪敏 |\n|  7. 测试   |   | 陈宇 |\n\n\n### 《深入浅出nodejs》\n\n| 课时章节       |  日期         |  讲师  |\n| ------------- |:-------------:| -----:|\n|  1. Chap1 - Chap2 Node简介及模块  |   | 徐佳 |\n|  2. Chap3 - Chap4 异步IO/异步编程  |   | 徐佳 |\n|  3. Chap5 内存管理  |   | 徐佳 |\n|  4. Chap6 理解Buffer  |   | 徐佳 |\n|  5. Chap7 网络编程　  |   | 徐佳 |\n|  6. Chap8 构建Web应用　  |   | 徐佳 |\n|  7. Chap9 玩转进程  |   | 徐佳 |\n|  8. Chap10 测试  |   | 徐佳 |\n|  9. Chap10 产品化　  |   | 徐佳 |\n|  10. 附录功能-调试Node\\Node编码规范　  |   | 徐佳 |\n","source":"_posts/Summary.md","raw":"---\ntitle: Summary\ndate: 2017-03-21 19:11:05\ntags:\n- react框架\n- RN技术\n- node技术\n---\n## node线分享书籍\n1. **《了不起的nodejs》**：分10个课时\n2. **《深入浅出nodejs》**：分10个课时\n\n## 课程表\n\n### 《了不起的nodejs》\n\n\n| 课时章节       |  日期         |  讲师  |\n| ------------- |:-------------:| -----:|\n|  1. 基础知识 |   | 陈宇 |\n|  2. CLI   |   | 倪敏 |\n|  3. TCP HTTP  |   | 徐佳 |\n|  4. Connect & Express   |   | 林宇宏 |\n|  5. 数据库   |   | 林宇宏 |\n|  6. Redis   |   | 倪敏 |\n|  7. 测试   |   | 陈宇 |\n\n\n### 《深入浅出nodejs》\n\n| 课时章节       |  日期         |  讲师  |\n| ------------- |:-------------:| -----:|\n|  1. Chap1 - Chap2 Node简介及模块  |   | 徐佳 |\n|  2. Chap3 - Chap4 异步IO/异步编程  |   | 徐佳 |\n|  3. Chap5 内存管理  |   | 徐佳 |\n|  4. Chap6 理解Buffer  |   | 徐佳 |\n|  5. Chap7 网络编程　  |   | 徐佳 |\n|  6. Chap8 构建Web应用　  |   | 徐佳 |\n|  7. Chap9 玩转进程  |   | 徐佳 |\n|  8. Chap10 测试  |   | 徐佳 |\n|  9. Chap10 产品化　  |   | 徐佳 |\n|  10. 附录功能-调试Node\\Node编码规范　  |   | 徐佳 |\n","slug":"Summary","published":1,"updated":"2017-03-30T05:17:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0w763oo000042cdmru6ihzn","content":"<h2 id=\"node线分享书籍\"><a href=\"#node线分享书籍\" class=\"headerlink\" title=\"node线分享书籍\"></a>node线分享书籍</h2><ol>\n<li><strong>《了不起的nodejs》</strong>：分10个课时</li>\n<li><strong>《深入浅出nodejs》</strong>：分10个课时</li>\n</ol>\n<h2 id=\"课程表\"><a href=\"#课程表\" class=\"headerlink\" title=\"课程表\"></a>课程表</h2><h3 id=\"《了不起的nodejs》\"><a href=\"#《了不起的nodejs》\" class=\"headerlink\" title=\"《了不起的nodejs》\"></a>《了不起的nodejs》</h3><table>\n<thead>\n<tr>\n<th>课时章节</th>\n<th style=\"text-align:center\">日期</th>\n<th style=\"text-align:right\">讲师</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. 基础知识</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">陈宇</td>\n</tr>\n<tr>\n<td>2. CLI</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">倪敏</td>\n</tr>\n<tr>\n<td>3. TCP HTTP</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>4. Connect &amp; Express</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">林宇宏</td>\n</tr>\n<tr>\n<td>5. 数据库</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">林宇宏</td>\n</tr>\n<tr>\n<td>6. Redis</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">倪敏</td>\n</tr>\n<tr>\n<td>7. 测试</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">陈宇</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"《深入浅出nodejs》\"><a href=\"#《深入浅出nodejs》\" class=\"headerlink\" title=\"《深入浅出nodejs》\"></a>《深入浅出nodejs》</h3><table>\n<thead>\n<tr>\n<th>课时章节</th>\n<th style=\"text-align:center\">日期</th>\n<th style=\"text-align:right\">讲师</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. Chap1 - Chap2 Node简介及模块</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>2. Chap3 - Chap4 异步IO/异步编程</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>3. Chap5 内存管理</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>4. Chap6 理解Buffer</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>5. Chap7 网络编程　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>6. Chap8 构建Web应用　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>7. Chap9 玩转进程</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>8. Chap10 测试</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>9. Chap10 产品化　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>10. 附录功能-调试Node\\Node编码规范　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h2 id=\"node线分享书籍\"><a href=\"#node线分享书籍\" class=\"headerlink\" title=\"node线分享书籍\"></a>node线分享书籍</h2><ol>\n<li><strong>《了不起的nodejs》</strong>：分10个课时</li>\n<li><strong>《深入浅出nodejs》</strong>：分10个课时</li>\n</ol>\n<h2 id=\"课程表\"><a href=\"#课程表\" class=\"headerlink\" title=\"课程表\"></a>课程表</h2><h3 id=\"《了不起的nodejs》\"><a href=\"#《了不起的nodejs》\" class=\"headerlink\" title=\"《了不起的nodejs》\"></a>《了不起的nodejs》</h3><table>\n<thead>\n<tr>\n<th>课时章节</th>\n<th style=\"text-align:center\">日期</th>\n<th style=\"text-align:right\">讲师</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. 基础知识</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">陈宇</td>\n</tr>\n<tr>\n<td>2. CLI</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">倪敏</td>\n</tr>\n<tr>\n<td>3. TCP HTTP</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>4. Connect &amp; Express</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">林宇宏</td>\n</tr>\n<tr>\n<td>5. 数据库</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">林宇宏</td>\n</tr>\n<tr>\n<td>6. Redis</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">倪敏</td>\n</tr>\n<tr>\n<td>7. 测试</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">陈宇</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"《深入浅出nodejs》\"><a href=\"#《深入浅出nodejs》\" class=\"headerlink\" title=\"《深入浅出nodejs》\"></a>《深入浅出nodejs》</h3><table>\n<thead>\n<tr>\n<th>课时章节</th>\n<th style=\"text-align:center\">日期</th>\n<th style=\"text-align:right\">讲师</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. Chap1 - Chap2 Node简介及模块</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>2. Chap3 - Chap4 异步IO/异步编程</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>3. Chap5 内存管理</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>4. Chap6 理解Buffer</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>5. Chap7 网络编程　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>6. Chap8 构建Web应用　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>7. Chap9 玩转进程</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>8. Chap10 测试</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>9. Chap10 产品化　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n<tr>\n<td>10. 附录功能-调试Node\\Node编码规范　</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">徐佳</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"background","date":"2017-03-26T09:10:09.000Z","_content":"### 背景：\n今年我和很多同学谈17年KPI的时候，发现很多同学都在说同一件事，就是想学习，想团队有一个持续的分享会，想有一个大牛来指导他们去学习。所以能看出来，大家都渴望新知识，都想团队有个持续的分享会。\n\n### 现状：\n目前分享会形式主要是‘散养’，大家自主选课题，自己感兴趣的主题分享，这种形式的分享有两个很大的困难\n1. 不固定，不持久，想来一发就一发。\n2. 主题与大家不match\n主讲在上面说，下面的同学用很渴望的眼神认真的听着，但就是听不懂。我一般一次分享会做完后，我都用问过其中的一些同学，没对主讲课题做一些基础的准备的话，绝大多数人都是这种情况。所以这种形式的分享最佳收益者是主讲人，对于听众效果应该不是最好的。\n所以年初来，我一直在考虑解决这个问题，能给大家一个固定又持久，不管对主讲还是对听众都有收获的分享会。\n\n正因为有目前分享会有这种问题，而且我们团队人越来越多啦，我相信团队对于这种分享技术的氛围会越来越强烈。所以我一直在想以哪种分享形式来解决这些问题。目前我有一些想法，也跟佳敏做了讨论，他还是肯定提倡我这种做法。所以我觉得是时候跟大家说下，看看大家的反馈。\n\n新分享会新主题增加：** “回归技术教程，做系列分享”**\n\n### 形式：\n引入学校上课形式，会以17年团队技术KPI的三块：** react框架、RN技术、node技术 **找三本经典教程，去买PDF版本，分发给大家。分享会根据制定出一个课程表，以章节作为一个课时，每周一节课来分享三本教程中的每一章内容。量不大吧？这样只要大家提前去看，带着每章的问题来听课，内容上跟讲师也能match上，可能效果会更好些。\n\n### 分享时间：\n 以课程表为准\n\n### 老师：\n每条线都以目前这三个技术方向的几个主要负责人来作为主讲老师，持续系列分享。当然我更希望是在坐的每位同学，提前看教程，自主提出当老师。我觉得大家都是从0基础开始，每个人都有资格来当老师，哪怕当老师犯了错，下面有经验的学生也会纠正，对你本人收益也是最大的。所以我提倡这种自主行为，为此我会设立讲师奖励。\n\n### 奖励：\n计划每个季度，对前三名讲师给予买书补贴（具体费用如下）。\n```\n一次/一季度的前三名次数讲师: (80+100+120) * 4个季度 = 1200\n一次/一季度的 Happy Time: 250 * 4 = 1000 ```\n\n分享博客站点： 1. 分享会讲师内容  2. 大家工作上或学习中的体会\n\n","source":"_posts/background.md","raw":"---\ntitle: background\ndate: 2017-03-26 17:10:09\ntags:\n---\n### 背景：\n今年我和很多同学谈17年KPI的时候，发现很多同学都在说同一件事，就是想学习，想团队有一个持续的分享会，想有一个大牛来指导他们去学习。所以能看出来，大家都渴望新知识，都想团队有个持续的分享会。\n\n### 现状：\n目前分享会形式主要是‘散养’，大家自主选课题，自己感兴趣的主题分享，这种形式的分享有两个很大的困难\n1. 不固定，不持久，想来一发就一发。\n2. 主题与大家不match\n主讲在上面说，下面的同学用很渴望的眼神认真的听着，但就是听不懂。我一般一次分享会做完后，我都用问过其中的一些同学，没对主讲课题做一些基础的准备的话，绝大多数人都是这种情况。所以这种形式的分享最佳收益者是主讲人，对于听众效果应该不是最好的。\n所以年初来，我一直在考虑解决这个问题，能给大家一个固定又持久，不管对主讲还是对听众都有收获的分享会。\n\n正因为有目前分享会有这种问题，而且我们团队人越来越多啦，我相信团队对于这种分享技术的氛围会越来越强烈。所以我一直在想以哪种分享形式来解决这些问题。目前我有一些想法，也跟佳敏做了讨论，他还是肯定提倡我这种做法。所以我觉得是时候跟大家说下，看看大家的反馈。\n\n新分享会新主题增加：** “回归技术教程，做系列分享”**\n\n### 形式：\n引入学校上课形式，会以17年团队技术KPI的三块：** react框架、RN技术、node技术 **找三本经典教程，去买PDF版本，分发给大家。分享会根据制定出一个课程表，以章节作为一个课时，每周一节课来分享三本教程中的每一章内容。量不大吧？这样只要大家提前去看，带着每章的问题来听课，内容上跟讲师也能match上，可能效果会更好些。\n\n### 分享时间：\n 以课程表为准\n\n### 老师：\n每条线都以目前这三个技术方向的几个主要负责人来作为主讲老师，持续系列分享。当然我更希望是在坐的每位同学，提前看教程，自主提出当老师。我觉得大家都是从0基础开始，每个人都有资格来当老师，哪怕当老师犯了错，下面有经验的学生也会纠正，对你本人收益也是最大的。所以我提倡这种自主行为，为此我会设立讲师奖励。\n\n### 奖励：\n计划每个季度，对前三名讲师给予买书补贴（具体费用如下）。\n```\n一次/一季度的前三名次数讲师: (80+100+120) * 4个季度 = 1200\n一次/一季度的 Happy Time: 250 * 4 = 1000 ```\n\n分享博客站点： 1. 分享会讲师内容  2. 大家工作上或学习中的体会\n\n","slug":"background","published":1,"updated":"2017-03-30T05:17:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0w763ou000142cdovf18ys2","content":"<h3 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h3><p>今年我和很多同学谈17年KPI的时候，发现很多同学都在说同一件事，就是想学习，想团队有一个持续的分享会，想有一个大牛来指导他们去学习。所以能看出来，大家都渴望新知识，都想团队有个持续的分享会。</p>\n<h3 id=\"现状：\"><a href=\"#现状：\" class=\"headerlink\" title=\"现状：\"></a>现状：</h3><p>目前分享会形式主要是‘散养’，大家自主选课题，自己感兴趣的主题分享，这种形式的分享有两个很大的困难</p>\n<ol>\n<li>不固定，不持久，想来一发就一发。</li>\n<li>主题与大家不match<br>主讲在上面说，下面的同学用很渴望的眼神认真的听着，但就是听不懂。我一般一次分享会做完后，我都用问过其中的一些同学，没对主讲课题做一些基础的准备的话，绝大多数人都是这种情况。所以这种形式的分享最佳收益者是主讲人，对于听众效果应该不是最好的。<br>所以年初来，我一直在考虑解决这个问题，能给大家一个固定又持久，不管对主讲还是对听众都有收获的分享会。</li>\n</ol>\n<p>正因为有目前分享会有这种问题，而且我们团队人越来越多啦，我相信团队对于这种分享技术的氛围会越来越强烈。所以我一直在想以哪种分享形式来解决这些问题。目前我有一些想法，也跟佳敏做了讨论，他还是肯定提倡我这种做法。所以我觉得是时候跟大家说下，看看大家的反馈。</p>\n<p>新分享会新主题增加：<strong> “回归技术教程，做系列分享”</strong></p>\n<h3 id=\"形式：\"><a href=\"#形式：\" class=\"headerlink\" title=\"形式：\"></a>形式：</h3><p>引入学校上课形式，会以17年团队技术KPI的三块：<strong> react框架、RN技术、node技术 </strong>找三本经典教程，去买PDF版本，分发给大家。分享会根据制定出一个课程表，以章节作为一个课时，每周一节课来分享三本教程中的每一章内容。量不大吧？这样只要大家提前去看，带着每章的问题来听课，内容上跟讲师也能match上，可能效果会更好些。</p>\n<h3 id=\"分享时间：\"><a href=\"#分享时间：\" class=\"headerlink\" title=\"分享时间：\"></a>分享时间：</h3><p> 以课程表为准</p>\n<h3 id=\"老师：\"><a href=\"#老师：\" class=\"headerlink\" title=\"老师：\"></a>老师：</h3><p>每条线都以目前这三个技术方向的几个主要负责人来作为主讲老师，持续系列分享。当然我更希望是在坐的每位同学，提前看教程，自主提出当老师。我觉得大家都是从0基础开始，每个人都有资格来当老师，哪怕当老师犯了错，下面有经验的学生也会纠正，对你本人收益也是最大的。所以我提倡这种自主行为，为此我会设立讲师奖励。</p>\n<h3 id=\"奖励：\"><a href=\"#奖励：\" class=\"headerlink\" title=\"奖励：\"></a>奖励：</h3><p>计划每个季度，对前三名讲师给予买书补贴（具体费用如下）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">一次/一季度的前三名次数讲师: (80+100+120) * 4个季度 = 1200</div><div class=\"line\">一次/一季度的 Happy Time: 250 * 4 = 1000</div></pre></td></tr></table></figure></p>\n<p>分享博客站点： 1. 分享会讲师内容  2. 大家工作上或学习中的体会</p>\n","excerpt":"","more":"<h3 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h3><p>今年我和很多同学谈17年KPI的时候，发现很多同学都在说同一件事，就是想学习，想团队有一个持续的分享会，想有一个大牛来指导他们去学习。所以能看出来，大家都渴望新知识，都想团队有个持续的分享会。</p>\n<h3 id=\"现状：\"><a href=\"#现状：\" class=\"headerlink\" title=\"现状：\"></a>现状：</h3><p>目前分享会形式主要是‘散养’，大家自主选课题，自己感兴趣的主题分享，这种形式的分享有两个很大的困难</p>\n<ol>\n<li>不固定，不持久，想来一发就一发。</li>\n<li>主题与大家不match<br>主讲在上面说，下面的同学用很渴望的眼神认真的听着，但就是听不懂。我一般一次分享会做完后，我都用问过其中的一些同学，没对主讲课题做一些基础的准备的话，绝大多数人都是这种情况。所以这种形式的分享最佳收益者是主讲人，对于听众效果应该不是最好的。<br>所以年初来，我一直在考虑解决这个问题，能给大家一个固定又持久，不管对主讲还是对听众都有收获的分享会。</li>\n</ol>\n<p>正因为有目前分享会有这种问题，而且我们团队人越来越多啦，我相信团队对于这种分享技术的氛围会越来越强烈。所以我一直在想以哪种分享形式来解决这些问题。目前我有一些想法，也跟佳敏做了讨论，他还是肯定提倡我这种做法。所以我觉得是时候跟大家说下，看看大家的反馈。</p>\n<p>新分享会新主题增加：<strong> “回归技术教程，做系列分享”</strong></p>\n<h3 id=\"形式：\"><a href=\"#形式：\" class=\"headerlink\" title=\"形式：\"></a>形式：</h3><p>引入学校上课形式，会以17年团队技术KPI的三块：<strong> react框架、RN技术、node技术 </strong>找三本经典教程，去买PDF版本，分发给大家。分享会根据制定出一个课程表，以章节作为一个课时，每周一节课来分享三本教程中的每一章内容。量不大吧？这样只要大家提前去看，带着每章的问题来听课，内容上跟讲师也能match上，可能效果会更好些。</p>\n<h3 id=\"分享时间：\"><a href=\"#分享时间：\" class=\"headerlink\" title=\"分享时间：\"></a>分享时间：</h3><p> 以课程表为准</p>\n<h3 id=\"老师：\"><a href=\"#老师：\" class=\"headerlink\" title=\"老师：\"></a>老师：</h3><p>每条线都以目前这三个技术方向的几个主要负责人来作为主讲老师，持续系列分享。当然我更希望是在坐的每位同学，提前看教程，自主提出当老师。我觉得大家都是从0基础开始，每个人都有资格来当老师，哪怕当老师犯了错，下面有经验的学生也会纠正，对你本人收益也是最大的。所以我提倡这种自主行为，为此我会设立讲师奖励。</p>\n<h3 id=\"奖励：\"><a href=\"#奖励：\" class=\"headerlink\" title=\"奖励：\"></a>奖励：</h3><p>计划每个季度，对前三名讲师给予买书补贴（具体费用如下）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">一次/一季度的前三名次数讲师: (80+100+120) * 4个季度 = 1200</div><div class=\"line\">一次/一季度的 Happy Time: 250 * 4 = 1000</div></pre></td></tr></table></figure></p>\n<p>分享博客站点： 1. 分享会讲师内容  2. 大家工作上或学习中的体会</p>\n"},{"title":"redux","date":"2017-03-28T10:06:37.000Z","_content":"# redux\n\n## 推荐文档\n\n1. redux 生态系统:http://cn.redux.js.org/docs/introduction/Ecosystem.html\n1. 中文官方文档: http://cn.redux.js.org/index.html\n2. 英文官方文档: http://redux.js.org/\n3. github精简教程: https://github.com/react-guide/redux-tutorial-cn#redux-tutorial\n\n## 什么是redux\n1. 随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。\n2. 通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。\n\n3. Redux是JS状态容器.提供可预测化的状态管理. \n\n\n## 三大原则\n\n1. 单一数据源\n    * 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。\n\n2. State 是只读的\n    * 惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n    \n3. 使用纯函数来执行修改\n    * 为了描述 action 如何改变 state tree ，你需要编写 reducers。\n    \n    \n## 现实案例\n公司项目代码trunk管理\n\n|...|对应关系| 职责|\n|:---:|:---:|:---:|\n|我们|action |表达修改trunk   代码的意图|\n|双星级想出来的修改的方法|reducers |改变公司代码|\n|双星级 |combine reducer |reducers集合|\n|trunk |store |存储公司代码状态的地方|\n\n\n\n\n\n## Action \n\n* 表达我们修改store的意图\n* 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state\n*   store 数据的唯一来源\n*   一般来说你会通过 store.dispatch() 将 action 传到 store    \n* Action 创建函数\n    * 在 Redux 中的 action 创建函数只是简单的返回一个 action\n```javascript\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n```\nAction.js\n```javascript\n/*\n * action 类型\n */\n\nexport const ADD_TODO = 'ADD_TODO';\nexport const TOGGLE_TODO = 'TOGGLE_TODO'\nexport const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'\n\n/*\n * 其它的常量\n */\n\nexport const VisibilityFilters = {\n  SHOW_ALL: 'SHOW_ALL',\n  SHOW_COMPLETED: 'SHOW_COMPLETED',\n  SHOW_ACTIVE: 'SHOW_ACTIVE'\n}\n\n/*\n * action 创建函数\n */\n\nexport function addTodo(text) {\n  return { type: ADD_TODO, text }\n}\n\nexport function toggleTodo(index) {\n  return { type: TOGGLE_TODO, index }\n}\n\nexport function setVisibilityFilter(filter) {\n  return { type: SET_VISIBILITY_FILTER, filter }\n}\n```\n\n## Reducer \n* Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。\n* Action 处理\n    * reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。\n* 不要直接修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { ...state, ...newState } 达到相同的目的。\n  \n* 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。\n* 在写reducer时候,注意store的数据结构\n\n## 纯函数 \n* 纯函数是指 不依赖于且不改变它作用域之外的变量状态的函数。\n* 也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。\n\n\n\n![](/img/ReduxFlow.png)\n\n#### connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\n\n#### [mapStateToProps(state, [ownProps]): stateProps]\n\n* (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。\n* 该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。\n* 如果你省略了这个参数，你的组件将不会监听 Redux store。\n* 如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。\n\n#### [mapDispatchToProps(dispatch, [ownProps]): dispatchProps] \n* (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。\n* 如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。\n* 如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。\n* 如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。\n     \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/redux.md","raw":"---\ntitle: redux\ndate: 2017-03-28 18:06:37\ntags:\n- RN技术\n---\n# redux\n\n## 推荐文档\n\n1. redux 生态系统:http://cn.redux.js.org/docs/introduction/Ecosystem.html\n1. 中文官方文档: http://cn.redux.js.org/index.html\n2. 英文官方文档: http://redux.js.org/\n3. github精简教程: https://github.com/react-guide/redux-tutorial-cn#redux-tutorial\n\n## 什么是redux\n1. 随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。\n2. 通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。\n\n3. Redux是JS状态容器.提供可预测化的状态管理. \n\n\n## 三大原则\n\n1. 单一数据源\n    * 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。\n\n2. State 是只读的\n    * 惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n    \n3. 使用纯函数来执行修改\n    * 为了描述 action 如何改变 state tree ，你需要编写 reducers。\n    \n    \n## 现实案例\n公司项目代码trunk管理\n\n|...|对应关系| 职责|\n|:---:|:---:|:---:|\n|我们|action |表达修改trunk   代码的意图|\n|双星级想出来的修改的方法|reducers |改变公司代码|\n|双星级 |combine reducer |reducers集合|\n|trunk |store |存储公司代码状态的地方|\n\n\n\n\n\n## Action \n\n* 表达我们修改store的意图\n* 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state\n*   store 数据的唯一来源\n*   一般来说你会通过 store.dispatch() 将 action 传到 store    \n* Action 创建函数\n    * 在 Redux 中的 action 创建函数只是简单的返回一个 action\n```javascript\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n```\nAction.js\n```javascript\n/*\n * action 类型\n */\n\nexport const ADD_TODO = 'ADD_TODO';\nexport const TOGGLE_TODO = 'TOGGLE_TODO'\nexport const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'\n\n/*\n * 其它的常量\n */\n\nexport const VisibilityFilters = {\n  SHOW_ALL: 'SHOW_ALL',\n  SHOW_COMPLETED: 'SHOW_COMPLETED',\n  SHOW_ACTIVE: 'SHOW_ACTIVE'\n}\n\n/*\n * action 创建函数\n */\n\nexport function addTodo(text) {\n  return { type: ADD_TODO, text }\n}\n\nexport function toggleTodo(index) {\n  return { type: TOGGLE_TODO, index }\n}\n\nexport function setVisibilityFilter(filter) {\n  return { type: SET_VISIBILITY_FILTER, filter }\n}\n```\n\n## Reducer \n* Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。\n* Action 处理\n    * reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。\n* 不要直接修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { ...state, ...newState } 达到相同的目的。\n  \n* 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。\n* 在写reducer时候,注意store的数据结构\n\n## 纯函数 \n* 纯函数是指 不依赖于且不改变它作用域之外的变量状态的函数。\n* 也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。\n\n\n\n![](/img/ReduxFlow.png)\n\n#### connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\n\n#### [mapStateToProps(state, [ownProps]): stateProps]\n\n* (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。\n* 该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。\n* 如果你省略了这个参数，你的组件将不会监听 Redux store。\n* 如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。\n\n#### [mapDispatchToProps(dispatch, [ownProps]): dispatchProps] \n* (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。\n* 如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。\n* 如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。\n* 如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。\n     \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"redux","published":1,"updated":"2017-03-30T05:17:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0w763p1000342cd7obrzvyr","content":"<h1 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h1><h2 id=\"推荐文档\"><a href=\"#推荐文档\" class=\"headerlink\" title=\"推荐文档\"></a>推荐文档</h2><ol>\n<li>redux 生态系统:<a href=\"http://cn.redux.js.org/docs/introduction/Ecosystem.html\" target=\"_blank\" rel=\"external\">http://cn.redux.js.org/docs/introduction/Ecosystem.html</a></li>\n<li>中文官方文档: <a href=\"http://cn.redux.js.org/index.html\" target=\"_blank\" rel=\"external\">http://cn.redux.js.org/index.html</a></li>\n<li>英文官方文档: <a href=\"http://redux.js.org/\" target=\"_blank\" rel=\"external\">http://redux.js.org/</a></li>\n<li>github精简教程: <a href=\"https://github.com/react-guide/redux-tutorial-cn#redux-tutorial\" target=\"_blank\" rel=\"external\">https://github.com/react-guide/redux-tutorial-cn#redux-tutorial</a></li>\n</ol>\n<h2 id=\"什么是redux\"><a href=\"#什么是redux\" class=\"headerlink\" title=\"什么是redux\"></a>什么是redux</h2><ol>\n<li>随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。</li>\n<li><p>通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。</p>\n</li>\n<li><p>Redux是JS状态容器.提供可预测化的状态管理. </p>\n</li>\n</ol>\n<h2 id=\"三大原则\"><a href=\"#三大原则\" class=\"headerlink\" title=\"三大原则\"></a>三大原则</h2><ol>\n<li><p>单一数据源</p>\n<ul>\n<li>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li>\n</ul>\n</li>\n<li><p>State 是只读的</p>\n<ul>\n<li>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li>\n</ul>\n</li>\n<li><p>使用纯函数来执行修改</p>\n<ul>\n<li>为了描述 action 如何改变 state tree ，你需要编写 reducers。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"现实案例\"><a href=\"#现实案例\" class=\"headerlink\" title=\"现实案例\"></a>现实案例</h2><p>公司项目代码trunk管理</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">…</th>\n<th style=\"text-align:center\">对应关系</th>\n<th style=\"text-align:center\">职责</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">我们</td>\n<td style=\"text-align:center\">action</td>\n<td style=\"text-align:center\">表达修改trunk   代码的意图</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">双星级想出来的修改的方法</td>\n<td style=\"text-align:center\">reducers</td>\n<td style=\"text-align:center\">改变公司代码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">双星级</td>\n<td style=\"text-align:center\">combine reducer</td>\n<td style=\"text-align:center\">reducers集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">trunk</td>\n<td style=\"text-align:center\">store</td>\n<td style=\"text-align:center\">存储公司代码状态的地方</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h2><ul>\n<li>表达我们修改store的意图</li>\n<li>只是描述了有事情发生了这一事实，并没有指明应用如何更新 state</li>\n<li>store 数据的唯一来源</li>\n<li>一般来说你会通过 store.dispatch() 将 action 传到 store    </li>\n<li>Action 创建函数<ul>\n<li>在 Redux 中的 action 创建函数只是简单的返回一个 action<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">type</span>: ADD_TODO,</div><div class=\"line\">    text</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>Action.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * action 类型</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO = <span class=\"string\">'ADD_TODO'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> TOGGLE_TODO = <span class=\"string\">'TOGGLE_TODO'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SET_VISIBILITY_FILTER = <span class=\"string\">'SET_VISIBILITY_FILTER'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * 其它的常量</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> VisibilityFilters = &#123;</div><div class=\"line\">  <span class=\"attr\">SHOW_ALL</span>: <span class=\"string\">'SHOW_ALL'</span>,</div><div class=\"line\">  <span class=\"attr\">SHOW_COMPLETED</span>: <span class=\"string\">'SHOW_COMPLETED'</span>,</div><div class=\"line\">  <span class=\"attr\">SHOW_ACTIVE</span>: <span class=\"string\">'SHOW_ACTIVE'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * action 创建函数</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: ADD_TODO, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toggleTodo</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: TOGGLE_TODO, index &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setVisibilityFilter</span>(<span class=\"params\">filter</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: SET_VISIBILITY_FILTER, filter &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><ul>\n<li>Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。</li>\n<li>Action 处理<ul>\n<li>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</li>\n</ul>\n</li>\n<li><p>不要直接修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。</p>\n</li>\n<li><p>在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。</p>\n</li>\n<li>在写reducer时候,注意store的数据结构</li>\n</ul>\n<h2 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h2><ul>\n<li>纯函数是指 不依赖于且不改变它作用域之外的变量状态的函数。</li>\n<li>也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。</li>\n</ul>\n<p><img src=\"/img/ReduxFlow.png\" alt=\"\"></p>\n<h4 id=\"connect-mapStateToProps-mapDispatchToProps-mergeProps-options\"><a href=\"#connect-mapStateToProps-mapDispatchToProps-mergeProps-options\" class=\"headerlink\" title=\"connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\"></a>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h4><h4 id=\"mapStateToProps-state-ownProps-stateProps\"><a href=\"#mapStateToProps-state-ownProps-stateProps\" class=\"headerlink\" title=\"[mapStateToProps(state, [ownProps]): stateProps]\"></a>[mapStateToProps(state, [ownProps]): stateProps]</h4><ul>\n<li>(Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。</li>\n<li>该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。</li>\n<li>如果你省略了这个参数，你的组件将不会监听 Redux store。</li>\n<li>如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</li>\n</ul>\n<h4 id=\"mapDispatchToProps-dispatch-ownProps-dispatchProps\"><a href=\"#mapDispatchToProps-dispatch-ownProps-dispatchProps\" class=\"headerlink\" title=\"[mapDispatchToProps(dispatch, [ownProps]): dispatchProps]\"></a>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps]</h4><ul>\n<li>(Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。</li>\n<li>如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。</li>\n<li>如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。</li>\n<li>如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h1><h2 id=\"推荐文档\"><a href=\"#推荐文档\" class=\"headerlink\" title=\"推荐文档\"></a>推荐文档</h2><ol>\n<li>redux 生态系统:<a href=\"http://cn.redux.js.org/docs/introduction/Ecosystem.html\">http://cn.redux.js.org/docs/introduction/Ecosystem.html</a></li>\n<li>中文官方文档: <a href=\"http://cn.redux.js.org/index.html\">http://cn.redux.js.org/index.html</a></li>\n<li>英文官方文档: <a href=\"http://redux.js.org/\">http://redux.js.org/</a></li>\n<li>github精简教程: <a href=\"https://github.com/react-guide/redux-tutorial-cn#redux-tutorial\">https://github.com/react-guide/redux-tutorial-cn#redux-tutorial</a></li>\n</ol>\n<h2 id=\"什么是redux\"><a href=\"#什么是redux\" class=\"headerlink\" title=\"什么是redux\"></a>什么是redux</h2><ol>\n<li>随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。</li>\n<li><p>通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。</p>\n</li>\n<li><p>Redux是JS状态容器.提供可预测化的状态管理. </p>\n</li>\n</ol>\n<h2 id=\"三大原则\"><a href=\"#三大原则\" class=\"headerlink\" title=\"三大原则\"></a>三大原则</h2><ol>\n<li><p>单一数据源</p>\n<ul>\n<li>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li>\n</ul>\n</li>\n<li><p>State 是只读的</p>\n<ul>\n<li>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li>\n</ul>\n</li>\n<li><p>使用纯函数来执行修改</p>\n<ul>\n<li>为了描述 action 如何改变 state tree ，你需要编写 reducers。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"现实案例\"><a href=\"#现实案例\" class=\"headerlink\" title=\"现实案例\"></a>现实案例</h2><p>公司项目代码trunk管理</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">…</th>\n<th style=\"text-align:center\">对应关系</th>\n<th style=\"text-align:center\">职责</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">我们</td>\n<td style=\"text-align:center\">action</td>\n<td style=\"text-align:center\">表达修改trunk   代码的意图</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">双星级想出来的修改的方法</td>\n<td style=\"text-align:center\">reducers</td>\n<td style=\"text-align:center\">改变公司代码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">双星级</td>\n<td style=\"text-align:center\">combine reducer</td>\n<td style=\"text-align:center\">reducers集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">trunk</td>\n<td style=\"text-align:center\">store</td>\n<td style=\"text-align:center\">存储公司代码状态的地方</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h2><ul>\n<li>表达我们修改store的意图</li>\n<li>只是描述了有事情发生了这一事实，并没有指明应用如何更新 state</li>\n<li>store 数据的唯一来源</li>\n<li>一般来说你会通过 store.dispatch() 将 action 传到 store    </li>\n<li>Action 创建函数<ul>\n<li>在 Redux 中的 action 创建函数只是简单的返回一个 action<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">type</span>: ADD_TODO,</div><div class=\"line\">    text</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>Action.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * action 类型</div><div class=\"line\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO = <span class=\"string\">'ADD_TODO'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> TOGGLE_TODO = <span class=\"string\">'TOGGLE_TODO'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SET_VISIBILITY_FILTER = <span class=\"string\">'SET_VISIBILITY_FILTER'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * 其它的常量</div><div class=\"line\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> VisibilityFilters = &#123;</div><div class=\"line\">  <span class=\"attr\">SHOW_ALL</span>: <span class=\"string\">'SHOW_ALL'</span>,</div><div class=\"line\">  <span class=\"attr\">SHOW_COMPLETED</span>: <span class=\"string\">'SHOW_COMPLETED'</span>,</div><div class=\"line\">  <span class=\"attr\">SHOW_ACTIVE</span>: <span class=\"string\">'SHOW_ACTIVE'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * action 创建函数</div><div class=\"line\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: ADD_TODO, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toggleTodo</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: TOGGLE_TODO, index &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setVisibilityFilter</span>(<span class=\"params\">filter</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: SET_VISIBILITY_FILTER, filter &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><ul>\n<li>Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。</li>\n<li>Action 处理<ul>\n<li>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</li>\n</ul>\n</li>\n<li><p>不要直接修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。</p>\n</li>\n<li><p>在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。</p>\n</li>\n<li>在写reducer时候,注意store的数据结构</li>\n</ul>\n<h2 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h2><ul>\n<li>纯函数是指 不依赖于且不改变它作用域之外的变量状态的函数。</li>\n<li>也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。</li>\n</ul>\n<p><img src=\"/img/ReduxFlow.png\" alt=\"\"></p>\n<h4 id=\"connect-mapStateToProps-mapDispatchToProps-mergeProps-options\"><a href=\"#connect-mapStateToProps-mapDispatchToProps-mergeProps-options\" class=\"headerlink\" title=\"connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\"></a>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h4><h4 id=\"mapStateToProps-state-ownProps-stateProps\"><a href=\"#mapStateToProps-state-ownProps-stateProps\" class=\"headerlink\" title=\"[mapStateToProps(state, [ownProps]): stateProps]\"></a>[mapStateToProps(state, [ownProps]): stateProps]</h4><ul>\n<li>(Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。</li>\n<li>该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。</li>\n<li>如果你省略了这个参数，你的组件将不会监听 Redux store。</li>\n<li>如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</li>\n</ul>\n<h4 id=\"mapDispatchToProps-dispatch-ownProps-dispatchProps\"><a href=\"#mapDispatchToProps-dispatch-ownProps-dispatchProps\" class=\"headerlink\" title=\"[mapDispatchToProps(dispatch, [ownProps]): dispatchProps]\"></a>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps]</h4><ul>\n<li>(Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。</li>\n<li>如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。</li>\n<li>如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。</li>\n<li>如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj0w763oo000042cdmru6ihzn","tag_id":"cj0w763ox000242cdrp9bx1kx","_id":"cj0w763p7000742cdv1t5cgjp"},{"post_id":"cj0w763oo000042cdmru6ihzn","tag_id":"cj0w763p2000442cdjmq7oxk1","_id":"cj0w763p7000842cd0iowy19r"},{"post_id":"cj0w763oo000042cdmru6ihzn","tag_id":"cj0w763p3000542cd8erzj5yh","_id":"cj0w763p8000942cde57yg1mk"},{"post_id":"cj0w763p1000342cd7obrzvyr","tag_id":"cj0w763p2000442cdjmq7oxk1","_id":"cj0w763p8000a42cdlpwek59j"}],"Tag":[{"name":"react框架","_id":"cj0w763ox000242cdrp9bx1kx"},{"name":"RN技术","_id":"cj0w763p2000442cdjmq7oxk1"},{"name":"node技术","_id":"cj0w763p3000542cd8erzj5yh"}]}}